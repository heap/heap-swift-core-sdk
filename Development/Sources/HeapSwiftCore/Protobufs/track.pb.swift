// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: track.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// contentsquare properties
struct CoreSdk_V1_CSProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// project id
  var cspid: String = String()

  /// pageview id
  var cspvid: String = String()

  /// session number
  var cssn: String = String()

  /// timestamp
  var csts: String = String()

  ///user id
  var csuu: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SessionReplayInfo sub-property
struct CoreSdk_V1_SessionReplayInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionReplayPlatform
  var platform: CoreSdk_V1_SessionReplayInfo.SessionReplayPlatform = .unspecified

  /// time of type google.protobuf.Timestamp
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// includes values like site id, session id, etc
  var urlMetadata: Dictionary<String,CoreSdk_V1_Value> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// SessionReplayPlatform types
  enum SessionReplayPlatform: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// None provided
    case unspecified // = 0

    /// Auryc
    case auryc // = 1

    /// Logrocket
    case logrocket // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .auryc
      case 2: self = .logrocket
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .auryc: return 1
      case .logrocket: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension CoreSdk_V1_SessionReplayInfo.SessionReplayPlatform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreSdk_V1_SessionReplayInfo.SessionReplayPlatform] = [
    .unspecified,
    .auryc,
    .logrocket,
  ]
}

#endif  // swift(>=4.2)

/// User property definition
struct CoreSdk_V1_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user id string
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// User's identity
  var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// initial referrer
  var initialReferrer: String {
    get {return _storage._initialReferrer ?? String()}
    set {_uniqueStorage()._initialReferrer = newValue}
  }
  /// Returns true if `initialReferrer` has been explicitly set.
  var hasInitialReferrer: Bool {return _storage._initialReferrer != nil}
  /// Clears the value of `initialReferrer`. Subsequent reads from it will return its default value.
  mutating func clearInitialReferrer() {_uniqueStorage()._initialReferrer = nil}

  /// initial search keyword
  var initialSearchKeyword: String {
    get {return _storage._initialSearchKeyword ?? String()}
    set {_uniqueStorage()._initialSearchKeyword = newValue}
  }
  /// Returns true if `initialSearchKeyword` has been explicitly set.
  var hasInitialSearchKeyword: Bool {return _storage._initialSearchKeyword != nil}
  /// Clears the value of `initialSearchKeyword`. Subsequent reads from it will return its default value.
  mutating func clearInitialSearchKeyword() {_uniqueStorage()._initialSearchKeyword = nil}

  /// initial utm
  var initialUtm: CoreSdk_V1_Utm {
    get {return _storage._initialUtm ?? CoreSdk_V1_Utm()}
    set {_uniqueStorage()._initialUtm = newValue}
  }
  /// Returns true if `initialUtm` has been explicitly set.
  var hasInitialUtm: Bool {return _storage._initialUtm != nil}
  /// Clears the value of `initialUtm`. Subsequent reads from it will return its default value.
  mutating func clearInitialUtm() {_uniqueStorage()._initialUtm = nil}

  /// initial pageview info
  var initialPageviewInfo: CoreSdk_V1_PageviewInfo {
    get {return _storage._initialPageviewInfo ?? CoreSdk_V1_PageviewInfo()}
    set {_uniqueStorage()._initialPageviewInfo = newValue}
  }
  /// Returns true if `initialPageviewInfo` has been explicitly set.
  var hasInitialPageviewInfo: Bool {return _storage._initialPageviewInfo != nil}
  /// Clears the value of `initialPageviewInfo`. Subsequent reads from it will return its default value.
  mutating func clearInitialPageviewInfo() {_uniqueStorage()._initialPageviewInfo = nil}

  /// property map
  var properties: Dictionary<String,CoreSdk_V1_Value> {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ElementNode property definition
struct CoreSdk_V1_ElementNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// heapjs:n
  var nodeName: String {
    get {return _nodeName ?? String()}
    set {_nodeName = newValue}
  }
  /// Returns true if `nodeName` has been explicitly set.
  var hasNodeName: Bool {return self._nodeName != nil}
  /// Clears the value of `nodeName`. Subsequent reads from it will return its default value.
  mutating func clearNodeName() {self._nodeName = nil}

  /// heapjs:c
  var nodeHtmlClass: String {
    get {return _nodeHtmlClass ?? String()}
    set {_nodeHtmlClass = newValue}
  }
  /// Returns true if `nodeHtmlClass` has been explicitly set.
  var hasNodeHtmlClass: Bool {return self._nodeHtmlClass != nil}
  /// Clears the value of `nodeHtmlClass`. Subsequent reads from it will return its default value.
  mutating func clearNodeHtmlClass() {self._nodeHtmlClass = nil}

  /// heapjs:i
  var nodeID: String {
    get {return _nodeID ?? String()}
    set {_nodeID = newValue}
  }
  /// Returns true if `nodeID` has been explicitly set.
  var hasNodeID: Bool {return self._nodeID != nil}
  /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
  mutating func clearNodeID() {self._nodeID = nil}

  /// heapjs:x
  var nodeText: String {
    get {return _nodeText ?? String()}
    set {_nodeText = newValue}
  }
  /// Returns true if `nodeText` has been explicitly set.
  var hasNodeText: Bool {return self._nodeText != nil}
  /// Clears the value of `nodeText`. Subsequent reads from it will return its default value.
  mutating func clearNodeText() {self._nodeText = nil}

  /// heapjs:h
  var href: String {
    get {return _href ?? String()}
    set {_href = newValue}
  }
  /// Returns true if `href` has been explicitly set.
  var hasHref: Bool {return self._href != nil}
  /// Clears the value of `href`. Subsequent reads from it will return its default value.
  mutating func clearHref() {self._href = nil}

  /// accessibility label primarily used by mobile
  var accessibilityLabel: String {
    get {return _accessibilityLabel ?? String()}
    set {_accessibilityLabel = newValue}
  }
  /// Returns true if `accessibilityLabel` has been explicitly set.
  var hasAccessibilityLabel: Bool {return self._accessibilityLabel != nil}
  /// Clears the value of `accessibilityLabel`. Subsequent reads from it will return its default value.
  mutating func clearAccessibilityLabel() {self._accessibilityLabel = nil}

  /// referencing property name primarily used by mobile
  var referencingPropertyName: String {
    get {return _referencingPropertyName ?? String()}
    set {_referencingPropertyName = newValue}
  }
  /// Returns true if `referencingPropertyName` has been explicitly set.
  var hasReferencingPropertyName: Bool {return self._referencingPropertyName != nil}
  /// Clears the value of `referencingPropertyName`. Subsequent reads from it will return its default value.
  mutating func clearReferencingPropertyName() {self._referencingPropertyName = nil}

  /// attribute map primarily used by mobile
  var attributes: Dictionary<String,CoreSdk_V1_Value> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nodeName: String? = nil
  fileprivate var _nodeHtmlClass: String? = nil
  fileprivate var _nodeID: String? = nil
  fileprivate var _nodeText: String? = nil
  fileprivate var _href: String? = nil
  fileprivate var _accessibilityLabel: String? = nil
  fileprivate var _referencingPropertyName: String? = nil
}

/// Extended event details
struct CoreSdk_V1_Interaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// First callback method that fired due to interaction
  var callbackName: String {
    get {return _callbackName ?? String()}
    set {_callbackName = newValue}
  }
  /// Returns true if `callbackName` has been explicitly set.
  var hasCallbackName: Bool {return self._callbackName != nil}
  /// Clears the value of `callbackName`. Subsequent reads from it will return its default value.
  mutating func clearCallbackName() {self._callbackName = nil}

  var kind: CoreSdk_V1_Interaction.OneOf_Kind? = nil

  /// eg. drag-and-dropped. Max 1024 UTF-16 code-units.
  var custom: String {
    get {
      if case .custom(let v)? = kind {return v}
      return String()
    }
    set {kind = .custom(newValue)}
  }

  /// heapjs:t
  var builtin: CoreSdk_V1_Interaction.BuiltinKind {
    get {
      if case .builtin(let v)? = kind {return v}
      return .unspecified
    }
    set {kind = .builtin(newValue)}
  }

  /// string representation of a node hierarchy
  var hierarchy: String {
    get {return _hierarchy ?? String()}
    set {_hierarchy = newValue}
  }
  /// Returns true if `hierarchy` has been explicitly set.
  var hasHierarchy: Bool {return self._hierarchy != nil}
  /// Clears the value of `hierarchy`. Subsequent reads from it will return its default value.
  mutating func clearHierarchy() {self._hierarchy = nil}

  /// hierarchical array of nodes with triggering node first
  var nodes: [CoreSdk_V1_ElementNode] = []

  /// any additional properties
  var sourceProperties: Dictionary<String,CoreSdk_V1_Value> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable {
    /// eg. drag-and-dropped. Max 1024 UTF-16 code-units.
    case custom(String)
    /// heapjs:t
    case builtin(CoreSdk_V1_Interaction.BuiltinKind)

  #if !swift(>=4.1)
    static func ==(lhs: CoreSdk_V1_Interaction.OneOf_Kind, rhs: CoreSdk_V1_Interaction.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.custom, .custom): return {
        guard case .custom(let l) = lhs, case .custom(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.builtin, .builtin): return {
        guard case .builtin(let l) = lhs, case .builtin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Builtin interaction types
  enum BuiltinKind: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// None provided
    case unspecified // = 0

    /// Click
    case click // = 1

    /// Touch
    case touch // = 2

    /// Change
    case change // = 3

    /// Submit
    case submit // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .click
      case 2: self = .touch
      case 3: self = .change
      case 4: self = .submit
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .click: return 1
      case .touch: return 2
      case .change: return 3
      case .submit: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _callbackName: String? = nil
  fileprivate var _hierarchy: String? = nil
}

#if swift(>=4.2)

extension CoreSdk_V1_Interaction.BuiltinKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreSdk_V1_Interaction.BuiltinKind] = [
    .unspecified,
    .click,
    .touch,
    .change,
    .submit,
  ]
}

#endif  // swift(>=4.2)

struct CoreSdk_V1_VersionChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var previousVersion: CoreSdk_V1_ApplicationInfo {
    get {return _previousVersion ?? CoreSdk_V1_ApplicationInfo()}
    set {_previousVersion = newValue}
  }
  /// Returns true if `previousVersion` has been explicitly set.
  var hasPreviousVersion: Bool {return self._previousVersion != nil}
  /// Clears the value of `previousVersion`. Subsequent reads from it will return its default value.
  mutating func clearPreviousVersion() {self._previousVersion = nil}

  var currentVersion: CoreSdk_V1_ApplicationInfo {
    get {return _currentVersion ?? CoreSdk_V1_ApplicationInfo()}
    set {_currentVersion = newValue}
  }
  /// Returns true if `currentVersion` has been explicitly set.
  var hasCurrentVersion: Bool {return self._currentVersion != nil}
  /// Clears the value of `currentVersion`. Subsequent reads from it will return its default value.
  mutating func clearCurrentVersion() {self._currentVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _previousVersion: CoreSdk_V1_ApplicationInfo? = nil
  fileprivate var _currentVersion: CoreSdk_V1_ApplicationInfo? = nil
}

struct CoreSdk_V1_ComponentTransition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of components that have gone from invisible to visible.
  var invisibleToVisible: [CoreSdk_V1_ElementNode] = []

  /// List of components that have gone from visible to invisible.
  var visibleToInvisible: [CoreSdk_V1_ElementNode] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Event property definition
struct CoreSdk_V1_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: CoreSdk_V1_Event.OneOf_Kind? = nil

  /// See Custom message definition
  var custom: CoreSdk_V1_Event.Custom {
    get {
      if case .custom(let v)? = kind {return v}
      return CoreSdk_V1_Event.Custom()
    }
    set {kind = .custom(newValue)}
  }

  /// See interaction message definition
  var interaction: CoreSdk_V1_Interaction {
    get {
      if case .interaction(let v)? = kind {return v}
      return CoreSdk_V1_Interaction()
    }
    set {kind = .interaction(newValue)}
  }

  /// See VersionChange message definition
  var versionChange: CoreSdk_V1_VersionChange {
    get {
      if case .versionChange(let v)? = kind {return v}
      return CoreSdk_V1_VersionChange()
    }
    set {kind = .versionChange(newValue)}
  }

  /// See component transition definition
  var componentTransition: CoreSdk_V1_ComponentTransition {
    get {
      if case .componentTransition(let v)? = kind {return v}
      return CoreSdk_V1_ComponentTransition()
    }
    set {kind = .componentTransition(newValue)}
  }

  /// Mobile app_visibility_state
  var appVisibilityState: CoreSdk_V1_Event.AppVisibility {
    get {return _appVisibilityState ?? .unknownUnspecified}
    set {_appVisibilityState = newValue}
  }
  /// Returns true if `appVisibilityState` has been explicitly set.
  var hasAppVisibilityState: Bool {return self._appVisibilityState != nil}
  /// Clears the value of `appVisibilityState`. Subsequent reads from it will return its default value.
  mutating func clearAppVisibilityState() {self._appVisibilityState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable {
    /// See Custom message definition
    case custom(CoreSdk_V1_Event.Custom)
    /// See interaction message definition
    case interaction(CoreSdk_V1_Interaction)
    /// See VersionChange message definition
    case versionChange(CoreSdk_V1_VersionChange)
    /// See component transition definition
    case componentTransition(CoreSdk_V1_ComponentTransition)

  #if !swift(>=4.1)
    static func ==(lhs: CoreSdk_V1_Event.OneOf_Kind, rhs: CoreSdk_V1_Event.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.custom, .custom): return {
        guard case .custom(let l) = lhs, case .custom(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.interaction, .interaction): return {
        guard case .interaction(let l) = lhs, case .interaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.versionChange, .versionChange): return {
        guard case .versionChange(let l) = lhs, case .versionChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.componentTransition, .componentTransition): return {
        guard case .componentTransition(let l) = lhs, case .componentTransition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Mobile app visibility
  enum AppVisibility: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Default value for unset/unknown app visibility state.
    case unknownUnspecified // = 0

    /// App is in background
    case backgrounded // = 1

    /// App is in foreground
    case foregrounded // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownUnspecified
      case 1: self = .backgrounded
      case 2: self = .foregrounded
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownUnspecified: return 0
      case .backgrounded: return 1
      case .foregrounded: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A custom event from the `track` API.
  struct Custom {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Custom name of event
    var name: String = String()

    /// Properties from `track`.
    var properties: Dictionary<String,CoreSdk_V1_Value> = [:]

    /// Properties from custom client-side sources hjs:sProps
    var sourceProperties: Dictionary<String,CoreSdk_V1_Value> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _appVisibilityState: CoreSdk_V1_Event.AppVisibility? = nil
}

#if swift(>=4.2)

extension CoreSdk_V1_Event.AppVisibility: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreSdk_V1_Event.AppVisibility] = [
    .unknownUnspecified,
    .backgrounded,
    .foregrounded,
  ]
}

#endif  // swift(>=4.2)

/// Message body
struct CoreSdk_V1_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// string id
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// string env_id
  var envID: String {
    get {return _storage._envID}
    set {_uniqueStorage()._envID = newValue}
  }

  /// string user_id
  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// string identity
  var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// timestamp of type google.protobuf.Timestamp
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {_uniqueStorage()._time = nil}

  /// The library that implements base functionality.
  var baseLibrary: CoreSdk_V1_LibraryInfo {
    get {return _storage._baseLibrary ?? CoreSdk_V1_LibraryInfo()}
    set {_uniqueStorage()._baseLibrary = newValue}
  }
  /// Returns true if `baseLibrary` has been explicitly set.
  var hasBaseLibrary: Bool {return _storage._baseLibrary != nil}
  /// Clears the value of `baseLibrary`. Subsequent reads from it will return its default value.
  mutating func clearBaseLibrary() {_uniqueStorage()._baseLibrary = nil}

  /// The library providing autocapture or language bridging.
  var sourceLibrary: CoreSdk_V1_LibraryInfo {
    get {return _storage._sourceLibrary ?? CoreSdk_V1_LibraryInfo()}
    set {_uniqueStorage()._sourceLibrary = newValue}
  }
  /// Returns true if `sourceLibrary` has been explicitly set.
  var hasSourceLibrary: Bool {return _storage._sourceLibrary != nil}
  /// Clears the value of `sourceLibrary`. Subsequent reads from it will return its default value.
  mutating func clearSourceLibrary() {_uniqueStorage()._sourceLibrary = nil}

  /// See ApplicationInfo definition
  var application: CoreSdk_V1_ApplicationInfo {
    get {return _storage._application ?? CoreSdk_V1_ApplicationInfo()}
    set {_uniqueStorage()._application = newValue}
  }
  /// Returns true if `application` has been explicitly set.
  var hasApplication: Bool {return _storage._application != nil}
  /// Clears the value of `application`. Subsequent reads from it will return its default value.
  mutating func clearApplication() {_uniqueStorage()._application = nil}

  /// See DeviceInfo definition
  var device: CoreSdk_V1_DeviceInfo {
    get {return _storage._device ?? CoreSdk_V1_DeviceInfo()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {_uniqueStorage()._device = nil}

  /// See SessionInfo message definition
  var sessionInfo: CoreSdk_V1_SessionInfo {
    get {return _storage._sessionInfo ?? CoreSdk_V1_SessionInfo()}
    set {_uniqueStorage()._sessionInfo = newValue}
  }
  /// Returns true if `sessionInfo` has been explicitly set.
  var hasSessionInfo: Bool {return _storage._sessionInfo != nil}
  /// Clears the value of `sessionInfo`. Subsequent reads from it will return its default value.
  mutating func clearSessionInfo() {_uniqueStorage()._sessionInfo = nil}

  /// See pageViewInfo message definition
  var pageviewInfo: CoreSdk_V1_PageviewInfo {
    get {return _storage._pageviewInfo ?? CoreSdk_V1_PageviewInfo()}
    set {_uniqueStorage()._pageviewInfo = newValue}
  }
  /// Returns true if `pageviewInfo` has been explicitly set.
  var hasPageviewInfo: Bool {return _storage._pageviewInfo != nil}
  /// Clears the value of `pageviewInfo`. Subsequent reads from it will return its default value.
  mutating func clearPageviewInfo() {_uniqueStorage()._pageviewInfo = nil}

  /// property map<string, Value>
  var properties: Dictionary<String,CoreSdk_V1_Value> {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  var kind: OneOf_Kind? {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// session
  var session: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .session(let v)? = _storage._kind {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {_uniqueStorage()._kind = .session(newValue)}
  }

  /// pageview
  var pageview: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .pageview(let v)? = _storage._kind {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {_uniqueStorage()._kind = .pageview(newValue)}
  }

  /// see Event message definition
  var event: CoreSdk_V1_Event {
    get {
      if case .event(let v)? = _storage._kind {return v}
      return CoreSdk_V1_Event()
    }
    set {_uniqueStorage()._kind = .event(newValue)}
  }

  /// see User message definition
  var user: CoreSdk_V1_User {
    get {
      if case .user(let v)? = _storage._kind {return v}
      return CoreSdk_V1_User()
    }
    set {_uniqueStorage()._kind = .user(newValue)}
  }

  /// see SessionReplayInfo message definition
  var sessionReplayInfo: CoreSdk_V1_SessionReplayInfo {
    get {return _storage._sessionReplayInfo ?? CoreSdk_V1_SessionReplayInfo()}
    set {_uniqueStorage()._sessionReplayInfo = newValue}
  }
  /// Returns true if `sessionReplayInfo` has been explicitly set.
  var hasSessionReplayInfo: Bool {return _storage._sessionReplayInfo != nil}
  /// Clears the value of `sessionReplayInfo`. Subsequent reads from it will return its default value.
  mutating func clearSessionReplayInfo() {_uniqueStorage()._sessionReplayInfo = nil}

  /// session_replay
  var sessionReplay: String {
    get {return _storage._sessionReplay ?? String()}
    set {_uniqueStorage()._sessionReplay = newValue}
  }
  /// Returns true if `sessionReplay` has been explicitly set.
  var hasSessionReplay: Bool {return _storage._sessionReplay != nil}
  /// Clears the value of `sessionReplay`. Subsequent reads from it will return its default value.
  mutating func clearSessionReplay() {_uniqueStorage()._sessionReplay = nil}

  /// Components that are user visible at the time the message is fired.
  var activeContexts: [CoreSdk_V1_ElementNode] {
    get {return _storage._activeContexts}
    set {_uniqueStorage()._activeContexts = newValue}
  }

  /// contentsquare properties
  var csProperties: CoreSdk_V1_CSProperties {
    get {return _storage._csProperties ?? CoreSdk_V1_CSProperties()}
    set {_uniqueStorage()._csProperties = newValue}
  }
  /// Returns true if `csProperties` has been explicitly set.
  var hasCsProperties: Bool {return _storage._csProperties != nil}
  /// Clears the value of `csProperties`. Subsequent reads from it will return its default value.
  mutating func clearCsProperties() {_uniqueStorage()._csProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable {
    /// session
    case session(SwiftProtobuf.Google_Protobuf_Empty)
    /// pageview
    case pageview(SwiftProtobuf.Google_Protobuf_Empty)
    /// see Event message definition
    case event(CoreSdk_V1_Event)
    /// see User message definition
    case user(CoreSdk_V1_User)

  #if !swift(>=4.1)
    static func ==(lhs: CoreSdk_V1_Message.OneOf_Kind, rhs: CoreSdk_V1_Message.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.session, .session): return {
        guard case .session(let l) = lhs, case .session(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pageview, .pageview): return {
        guard case .pageview(let l) = lhs, case .pageview(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.event, .event): return {
        guard case .event(let l) = lhs, case .event(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.user, .user): return {
        guard case .user(let l) = lhs, case .user(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// message batch events container
struct CoreSdk_V1_MessageBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// array of events
  var events: [CoreSdk_V1_Message] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PostMobileTrackRequest
struct CoreSdk_V1_PostMobileTrackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageBatch: CoreSdk_V1_MessageBatch {
    get {return _messageBatch ?? CoreSdk_V1_MessageBatch()}
    set {_messageBatch = newValue}
  }
  /// Returns true if `messageBatch` has been explicitly set.
  var hasMessageBatch: Bool {return self._messageBatch != nil}
  /// Clears the value of `messageBatch`. Subsequent reads from it will return its default value.
  mutating func clearMessageBatch() {self._messageBatch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _messageBatch: CoreSdk_V1_MessageBatch? = nil
}

/// PostMobileTrackResponse
struct CoreSdk_V1_PostMobileTrackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension CoreSdk_V1_CSProperties: @unchecked Sendable {}
extension CoreSdk_V1_SessionReplayInfo: @unchecked Sendable {}
extension CoreSdk_V1_SessionReplayInfo.SessionReplayPlatform: @unchecked Sendable {}
extension CoreSdk_V1_User: @unchecked Sendable {}
extension CoreSdk_V1_ElementNode: @unchecked Sendable {}
extension CoreSdk_V1_Interaction: @unchecked Sendable {}
extension CoreSdk_V1_Interaction.OneOf_Kind: @unchecked Sendable {}
extension CoreSdk_V1_Interaction.BuiltinKind: @unchecked Sendable {}
extension CoreSdk_V1_VersionChange: @unchecked Sendable {}
extension CoreSdk_V1_ComponentTransition: @unchecked Sendable {}
extension CoreSdk_V1_Event: @unchecked Sendable {}
extension CoreSdk_V1_Event.OneOf_Kind: @unchecked Sendable {}
extension CoreSdk_V1_Event.AppVisibility: @unchecked Sendable {}
extension CoreSdk_V1_Event.Custom: @unchecked Sendable {}
extension CoreSdk_V1_Message: @unchecked Sendable {}
extension CoreSdk_V1_Message.OneOf_Kind: @unchecked Sendable {}
extension CoreSdk_V1_MessageBatch: @unchecked Sendable {}
extension CoreSdk_V1_PostMobileTrackRequest: @unchecked Sendable {}
extension CoreSdk_V1_PostMobileTrackResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "core_sdk.v1"

extension CoreSdk_V1_CSProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CSProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cspid"),
    2: .same(proto: "cspvid"),
    3: .same(proto: "cssn"),
    4: .same(proto: "csts"),
    5: .same(proto: "csuu"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cspid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cspvid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cssn) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.csts) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.csuu) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cspid.isEmpty {
      try visitor.visitSingularStringField(value: self.cspid, fieldNumber: 1)
    }
    if !self.cspvid.isEmpty {
      try visitor.visitSingularStringField(value: self.cspvid, fieldNumber: 2)
    }
    if !self.cssn.isEmpty {
      try visitor.visitSingularStringField(value: self.cssn, fieldNumber: 3)
    }
    if !self.csts.isEmpty {
      try visitor.visitSingularStringField(value: self.csts, fieldNumber: 4)
    }
    if !self.csuu.isEmpty {
      try visitor.visitSingularStringField(value: self.csuu, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_CSProperties, rhs: CoreSdk_V1_CSProperties) -> Bool {
    if lhs.cspid != rhs.cspid {return false}
    if lhs.cspvid != rhs.cspvid {return false}
    if lhs.cssn != rhs.cssn {return false}
    if lhs.csts != rhs.csts {return false}
    if lhs.csuu != rhs.csuu {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_SessionReplayInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionReplayInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .same(proto: "time"),
    3: .standard(proto: "url_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &self.urlMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.platform != .unspecified {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 1)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.urlMetadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: self.urlMetadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_SessionReplayInfo, rhs: CoreSdk_V1_SessionReplayInfo) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs._time != rhs._time {return false}
    if lhs.urlMetadata != rhs.urlMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_SessionReplayInfo.SessionReplayPlatform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SESSION_REPLAY_PLATFORM_UNSPECIFIED"),
    1: .same(proto: "SESSION_REPLAY_PLATFORM_AURYC"),
    2: .same(proto: "SESSION_REPLAY_PLATFORM_LOGROCKET"),
  ]
}

extension CoreSdk_V1_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "identity"),
    3: .standard(proto: "initial_referrer"),
    4: .standard(proto: "initial_search_keyword"),
    5: .standard(proto: "initial_utm"),
    6: .standard(proto: "initial_pageview_info"),
    7: .same(proto: "properties"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _identity: String = String()
    var _initialReferrer: String? = nil
    var _initialSearchKeyword: String? = nil
    var _initialUtm: CoreSdk_V1_Utm? = nil
    var _initialPageviewInfo: CoreSdk_V1_PageviewInfo? = nil
    var _properties: Dictionary<String,CoreSdk_V1_Value> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _identity = source._identity
      _initialReferrer = source._initialReferrer
      _initialSearchKeyword = source._initialSearchKeyword
      _initialUtm = source._initialUtm
      _initialPageviewInfo = source._initialPageviewInfo
      _properties = source._properties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._initialReferrer) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._initialSearchKeyword) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._initialUtm) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._initialPageviewInfo) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &_storage._properties) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 2)
      }
      try { if let v = _storage._initialReferrer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._initialSearchKeyword {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._initialUtm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._initialPageviewInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._properties.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: _storage._properties, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_User, rhs: CoreSdk_V1_User) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._initialReferrer != rhs_storage._initialReferrer {return false}
        if _storage._initialSearchKeyword != rhs_storage._initialSearchKeyword {return false}
        if _storage._initialUtm != rhs_storage._initialUtm {return false}
        if _storage._initialPageviewInfo != rhs_storage._initialPageviewInfo {return false}
        if _storage._properties != rhs_storage._properties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_ElementNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ElementNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_name"),
    2: .standard(proto: "node_html_class"),
    3: .standard(proto: "node_id"),
    4: .standard(proto: "node_text"),
    5: .same(proto: "href"),
    6: .standard(proto: "accessibility_label"),
    7: .standard(proto: "referencing_property_name"),
    8: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._nodeName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._nodeHtmlClass) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._nodeID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._nodeText) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._href) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._accessibilityLabel) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._referencingPropertyName) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nodeHtmlClass {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._nodeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._nodeText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._href {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._accessibilityLabel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._referencingPropertyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: self.attributes, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_ElementNode, rhs: CoreSdk_V1_ElementNode) -> Bool {
    if lhs._nodeName != rhs._nodeName {return false}
    if lhs._nodeHtmlClass != rhs._nodeHtmlClass {return false}
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._nodeText != rhs._nodeText {return false}
    if lhs._href != rhs._href {return false}
    if lhs._accessibilityLabel != rhs._accessibilityLabel {return false}
    if lhs._referencingPropertyName != rhs._referencingPropertyName {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_Interaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Interaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "callback_name"),
    2: .same(proto: "custom"),
    3: .same(proto: "builtin"),
    4: .same(proto: "hierarchy"),
    5: .same(proto: "nodes"),
    6: .standard(proto: "source_properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._callbackName) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .custom(v)
        }
      }()
      case 3: try {
        var v: CoreSdk_V1_Interaction.BuiltinKind?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .builtin(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._hierarchy) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &self.sourceProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callbackName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    switch self.kind {
    case .custom?: try {
      guard case .custom(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .builtin?: try {
      guard case .builtin(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._hierarchy {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 5)
    }
    if !self.sourceProperties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: self.sourceProperties, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_Interaction, rhs: CoreSdk_V1_Interaction) -> Bool {
    if lhs._callbackName != rhs._callbackName {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs._hierarchy != rhs._hierarchy {return false}
    if lhs.nodes != rhs.nodes {return false}
    if lhs.sourceProperties != rhs.sourceProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_Interaction.BuiltinKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUILTIN_KIND_UNSPECIFIED"),
    1: .same(proto: "BUILTIN_KIND_CLICK"),
    2: .same(proto: "BUILTIN_KIND_TOUCH"),
    3: .same(proto: "BUILTIN_KIND_CHANGE"),
    4: .same(proto: "BUILTIN_KIND_SUBMIT"),
  ]
}

extension CoreSdk_V1_VersionChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VersionChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "previous_version"),
    2: .standard(proto: "current_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._previousVersion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._currentVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._previousVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._currentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_VersionChange, rhs: CoreSdk_V1_VersionChange) -> Bool {
    if lhs._previousVersion != rhs._previousVersion {return false}
    if lhs._currentVersion != rhs._currentVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_ComponentTransition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ComponentTransition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invisible_to_visible"),
    2: .standard(proto: "visible_to_invisible"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.invisibleToVisible) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.visibleToInvisible) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invisibleToVisible.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invisibleToVisible, fieldNumber: 1)
    }
    if !self.visibleToInvisible.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.visibleToInvisible, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_ComponentTransition, rhs: CoreSdk_V1_ComponentTransition) -> Bool {
    if lhs.invisibleToVisible != rhs.invisibleToVisible {return false}
    if lhs.visibleToInvisible != rhs.visibleToInvisible {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "custom"),
    2: .same(proto: "interaction"),
    3: .standard(proto: "version_change"),
    4: .standard(proto: "component_transition"),
    20: .standard(proto: "app_visibility_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CoreSdk_V1_Event.Custom?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .custom(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .custom(v)
        }
      }()
      case 2: try {
        var v: CoreSdk_V1_Interaction?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .interaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .interaction(v)
        }
      }()
      case 3: try {
        var v: CoreSdk_V1_VersionChange?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .versionChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .versionChange(v)
        }
      }()
      case 4: try {
        var v: CoreSdk_V1_ComponentTransition?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .componentTransition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .componentTransition(v)
        }
      }()
      case 20: try { try decoder.decodeSingularEnumField(value: &self._appVisibilityState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .custom?: try {
      guard case .custom(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .interaction?: try {
      guard case .interaction(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .versionChange?: try {
      guard case .versionChange(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .componentTransition?: try {
      guard case .componentTransition(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try { if let v = self._appVisibilityState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 20)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_Event, rhs: CoreSdk_V1_Event) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._appVisibilityState != rhs._appVisibilityState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_Event.AppVisibility: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_VISIBILITY_UNKNOWN_UNSPECIFIED"),
    1: .same(proto: "APP_VISIBILITY_BACKGROUNDED"),
    2: .same(proto: "APP_VISIBILITY_FOREGROUNDED"),
  ]
}

extension CoreSdk_V1_Event.Custom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreSdk_V1_Event.protoMessageName + ".Custom"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "properties"),
    3: .standard(proto: "source_properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &self.properties) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &self.sourceProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.properties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: self.properties, fieldNumber: 2)
    }
    if !self.sourceProperties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: self.sourceProperties, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_Event.Custom, rhs: CoreSdk_V1_Event.Custom) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.sourceProperties != rhs.sourceProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "env_id"),
    3: .standard(proto: "user_id"),
    19: .same(proto: "identity"),
    4: .same(proto: "time"),
    5: .standard(proto: "base_library"),
    6: .standard(proto: "source_library"),
    7: .same(proto: "application"),
    8: .same(proto: "device"),
    9: .standard(proto: "session_info"),
    10: .standard(proto: "pageview_info"),
    11: .same(proto: "properties"),
    12: .same(proto: "session"),
    13: .same(proto: "pageview"),
    14: .same(proto: "event"),
    15: .same(proto: "user"),
    16: .standard(proto: "session_replay_info"),
    17: .standard(proto: "session_replay"),
    18: .standard(proto: "active_contexts"),
    20: .standard(proto: "cs_properties"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _envID: String = String()
    var _userID: String = String()
    var _identity: String = String()
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _baseLibrary: CoreSdk_V1_LibraryInfo? = nil
    var _sourceLibrary: CoreSdk_V1_LibraryInfo? = nil
    var _application: CoreSdk_V1_ApplicationInfo? = nil
    var _device: CoreSdk_V1_DeviceInfo? = nil
    var _sessionInfo: CoreSdk_V1_SessionInfo? = nil
    var _pageviewInfo: CoreSdk_V1_PageviewInfo? = nil
    var _properties: Dictionary<String,CoreSdk_V1_Value> = [:]
    var _kind: CoreSdk_V1_Message.OneOf_Kind?
    var _sessionReplayInfo: CoreSdk_V1_SessionReplayInfo? = nil
    var _sessionReplay: String? = nil
    var _activeContexts: [CoreSdk_V1_ElementNode] = []
    var _csProperties: CoreSdk_V1_CSProperties? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _envID = source._envID
      _userID = source._userID
      _identity = source._identity
      _time = source._time
      _baseLibrary = source._baseLibrary
      _sourceLibrary = source._sourceLibrary
      _application = source._application
      _device = source._device
      _sessionInfo = source._sessionInfo
      _pageviewInfo = source._pageviewInfo
      _properties = source._properties
      _kind = source._kind
      _sessionReplayInfo = source._sessionReplayInfo
      _sessionReplay = source._sessionReplay
      _activeContexts = source._activeContexts
      _csProperties = source._csProperties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._envID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._time) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._baseLibrary) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sourceLibrary) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._application) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._sessionInfo) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._pageviewInfo) }()
        case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &_storage._properties) }()
        case 12: try {
          var v: SwiftProtobuf.Google_Protobuf_Empty?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .session(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .session(v)
          }
        }()
        case 13: try {
          var v: SwiftProtobuf.Google_Protobuf_Empty?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .pageview(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .pageview(v)
          }
        }()
        case 14: try {
          var v: CoreSdk_V1_Event?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .event(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .event(v)
          }
        }()
        case 15: try {
          var v: CoreSdk_V1_User?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .user(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .user(v)
          }
        }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._sessionReplayInfo) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._sessionReplay) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._activeContexts) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._csProperties) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._envID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._envID, fieldNumber: 2)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 3)
      }
      try { if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._baseLibrary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sourceLibrary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._application {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._sessionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._pageviewInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._properties.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: _storage._properties, fieldNumber: 11)
      }
      switch _storage._kind {
      case .session?: try {
        guard case .session(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .pageview?: try {
        guard case .pageview(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .event?: try {
        guard case .event(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .user?: try {
        guard case .user(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case nil: break
      }
      try { if let v = _storage._sessionReplayInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._sessionReplay {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
      if !_storage._activeContexts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activeContexts, fieldNumber: 18)
      }
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 19)
      }
      try { if let v = _storage._csProperties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_Message, rhs: CoreSdk_V1_Message) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._envID != rhs_storage._envID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._baseLibrary != rhs_storage._baseLibrary {return false}
        if _storage._sourceLibrary != rhs_storage._sourceLibrary {return false}
        if _storage._application != rhs_storage._application {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._sessionInfo != rhs_storage._sessionInfo {return false}
        if _storage._pageviewInfo != rhs_storage._pageviewInfo {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._sessionReplayInfo != rhs_storage._sessionReplayInfo {return false}
        if _storage._sessionReplay != rhs_storage._sessionReplay {return false}
        if _storage._activeContexts != rhs_storage._activeContexts {return false}
        if _storage._csProperties != rhs_storage._csProperties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_MessageBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_MessageBatch, rhs: CoreSdk_V1_MessageBatch) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_PostMobileTrackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostMobileTrackRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_batch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messageBatch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageBatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_PostMobileTrackRequest, rhs: CoreSdk_V1_PostMobileTrackRequest) -> Bool {
    if lhs._messageBatch != rhs._messageBatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_PostMobileTrackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostMobileTrackResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_PostMobileTrackResponse, rhs: CoreSdk_V1_PostMobileTrackResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
