// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: track.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
#if BUILD_HEAP_SWIFT_CORE_FOR_DEVELOPMENT
import SwiftProtobuf
#else
@_implementationOnly import SwiftProtobuf
#endif

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct CoreSdk_V1_Utm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: String = String()

  var medium: String = String()

  var term: String = String()

  var content: String = String()

  var campaign: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SessionReplayInfo sub-property
struct CoreSdk_V1_SessionReplayInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionReplayPlatform
  var platform: CoreSdk_V1_SessionReplayInfo.SessionReplayPlatform = .unspecified

  /// time of type google.protobuf.Timestamp
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// includes values like site id, session id, etc
  var urlMetadata: Dictionary<String,CoreSdk_V1_Value> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// SessionReplayPlatform types
  enum SessionReplayPlatform: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// None provided
    case unspecified // = 0

    /// Auryc
    case auryc // = 1

    /// Logrocket
    case logrocket // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .auryc
      case 2: self = .logrocket
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .auryc: return 1
      case .logrocket: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension CoreSdk_V1_SessionReplayInfo.SessionReplayPlatform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreSdk_V1_SessionReplayInfo.SessionReplayPlatform] = [
    .unspecified,
    .auryc,
    .logrocket,
  ]
}

#endif  // swift(>=4.2)

/// SessionInfo sub-property definition
struct CoreSdk_V1_SessionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// string id
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// time of type google.protobuf.Timestamp
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {_uniqueStorage()._time = nil}

  /// referrer
  var referrer: String {
    get {return _storage._referrer ?? String()}
    set {_uniqueStorage()._referrer = newValue}
  }
  /// Returns true if `referrer` has been explicitly set.
  var hasReferrer: Bool {return _storage._referrer != nil}
  /// Clears the value of `referrer`. Subsequent reads from it will return its default value.
  mutating func clearReferrer() {_uniqueStorage()._referrer = nil}

  /// search_keyword
  var searchKeyword: String {
    get {return _storage._searchKeyword ?? String()}
    set {_uniqueStorage()._searchKeyword = newValue}
  }
  /// Returns true if `searchKeyword` has been explicitly set.
  var hasSearchKeyword: Bool {return _storage._searchKeyword != nil}
  /// Clears the value of `searchKeyword`. Subsequent reads from it will return its default value.
  mutating func clearSearchKeyword() {_uniqueStorage()._searchKeyword = nil}

  /// utm
  var utm: CoreSdk_V1_Utm {
    get {return _storage._utm ?? CoreSdk_V1_Utm()}
    set {_uniqueStorage()._utm = newValue}
  }
  /// Returns true if `utm` has been explicitly set.
  var hasUtm: Bool {return _storage._utm != nil}
  /// Clears the value of `utm`. Subsequent reads from it will return its default value.
  mutating func clearUtm() {_uniqueStorage()._utm = nil}

  /// PageviewInfo object
  var initialPageviewInfo: CoreSdk_V1_PageviewInfo {
    get {return _storage._initialPageviewInfo ?? CoreSdk_V1_PageviewInfo()}
    set {_uniqueStorage()._initialPageviewInfo = newValue}
  }
  /// Returns true if `initialPageviewInfo` has been explicitly set.
  var hasInitialPageviewInfo: Bool {return _storage._initialPageviewInfo != nil}
  /// Clears the value of `initialPageviewInfo`. Subsequent reads from it will return its default value.
  mutating func clearInitialPageviewInfo() {_uniqueStorage()._initialPageviewInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Pageview property defintion
struct CoreSdk_V1_PageviewInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Pageview id. (heapjs:v)
  var id: String = String()

  /// heapjs:ts
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// View controller, activity, ReactNative control name
  var componentOrClassName: String {
    get {return _componentOrClassName ?? String()}
    set {_componentOrClassName = newValue}
  }
  /// Returns true if `componentOrClassName` has been explicitly set.
  var hasComponentOrClassName: Bool {return self._componentOrClassName != nil}
  /// Clears the value of `componentOrClassName`. Subsequent reads from it will return its default value.
  mutating func clearComponentOrClassName() {self._componentOrClassName = nil}

  /// Web page or view controller title
  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  /// Web page URL
  var url: CoreSdk_V1_PageviewInfo.Url {
    get {return _url ?? CoreSdk_V1_PageviewInfo.Url()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  /// Source-specific properties
  var sourceProperties: Dictionary<String,CoreSdk_V1_Value> = [:]

  /// heapjs:pr
  var previousPage: String {
    get {return _previousPage ?? String()}
    set {_previousPage = newValue}
  }
  /// Returns true if `previousPage` has been explicitly set.
  var hasPreviousPage: Bool {return self._previousPage != nil}
  /// Clears the value of `previousPage`. Subsequent reads from it will return its default value.
  mutating func clearPreviousPage() {self._previousPage = nil}

  /// custom pageview properties (heapjs:k)
  var properties: Dictionary<String,CoreSdk_V1_Value> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Url message definition
  struct Url {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var domain: String = String()

    var path: String = String()

    var query: String = String()

    var hash: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _componentOrClassName: String? = nil
  fileprivate var _title: String? = nil
  fileprivate var _url: CoreSdk_V1_PageviewInfo.Url? = nil
  fileprivate var _previousPage: String? = nil
}

/// User property definition
struct CoreSdk_V1_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user id string
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// User's identity
  var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// initial referrer
  var initialReferrer: String {
    get {return _storage._initialReferrer ?? String()}
    set {_uniqueStorage()._initialReferrer = newValue}
  }
  /// Returns true if `initialReferrer` has been explicitly set.
  var hasInitialReferrer: Bool {return _storage._initialReferrer != nil}
  /// Clears the value of `initialReferrer`. Subsequent reads from it will return its default value.
  mutating func clearInitialReferrer() {_uniqueStorage()._initialReferrer = nil}

  /// initial search keyword
  var initialSearchKeyword: String {
    get {return _storage._initialSearchKeyword ?? String()}
    set {_uniqueStorage()._initialSearchKeyword = newValue}
  }
  /// Returns true if `initialSearchKeyword` has been explicitly set.
  var hasInitialSearchKeyword: Bool {return _storage._initialSearchKeyword != nil}
  /// Clears the value of `initialSearchKeyword`. Subsequent reads from it will return its default value.
  mutating func clearInitialSearchKeyword() {_uniqueStorage()._initialSearchKeyword = nil}

  /// initial utm
  var initialUtm: CoreSdk_V1_Utm {
    get {return _storage._initialUtm ?? CoreSdk_V1_Utm()}
    set {_uniqueStorage()._initialUtm = newValue}
  }
  /// Returns true if `initialUtm` has been explicitly set.
  var hasInitialUtm: Bool {return _storage._initialUtm != nil}
  /// Clears the value of `initialUtm`. Subsequent reads from it will return its default value.
  mutating func clearInitialUtm() {_uniqueStorage()._initialUtm = nil}

  /// initial pageview info
  var initialPageviewInfo: CoreSdk_V1_PageviewInfo {
    get {return _storage._initialPageviewInfo ?? CoreSdk_V1_PageviewInfo()}
    set {_uniqueStorage()._initialPageviewInfo = newValue}
  }
  /// Returns true if `initialPageviewInfo` has been explicitly set.
  var hasInitialPageviewInfo: Bool {return _storage._initialPageviewInfo != nil}
  /// Clears the value of `initialPageviewInfo`. Subsequent reads from it will return its default value.
  mutating func clearInitialPageviewInfo() {_uniqueStorage()._initialPageviewInfo = nil}

  /// property map
  var properties: Dictionary<String,CoreSdk_V1_Value> {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ElementNode property definition
struct CoreSdk_V1_ElementNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// heapjs:n
  var nodeName: String {
    get {return _nodeName ?? String()}
    set {_nodeName = newValue}
  }
  /// Returns true if `nodeName` has been explicitly set.
  var hasNodeName: Bool {return self._nodeName != nil}
  /// Clears the value of `nodeName`. Subsequent reads from it will return its default value.
  mutating func clearNodeName() {self._nodeName = nil}

  /// heapjs:c
  var nodeHtmlClass: String {
    get {return _nodeHtmlClass ?? String()}
    set {_nodeHtmlClass = newValue}
  }
  /// Returns true if `nodeHtmlClass` has been explicitly set.
  var hasNodeHtmlClass: Bool {return self._nodeHtmlClass != nil}
  /// Clears the value of `nodeHtmlClass`. Subsequent reads from it will return its default value.
  mutating func clearNodeHtmlClass() {self._nodeHtmlClass = nil}

  /// heapjs:i
  var nodeID: String {
    get {return _nodeID ?? String()}
    set {_nodeID = newValue}
  }
  /// Returns true if `nodeID` has been explicitly set.
  var hasNodeID: Bool {return self._nodeID != nil}
  /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
  mutating func clearNodeID() {self._nodeID = nil}

  /// heapjs:x
  var nodeText: String {
    get {return _nodeText ?? String()}
    set {_nodeText = newValue}
  }
  /// Returns true if `nodeText` has been explicitly set.
  var hasNodeText: Bool {return self._nodeText != nil}
  /// Clears the value of `nodeText`. Subsequent reads from it will return its default value.
  mutating func clearNodeText() {self._nodeText = nil}

  /// heapjs:h
  var href: String {
    get {return _href ?? String()}
    set {_href = newValue}
  }
  /// Returns true if `href` has been explicitly set.
  var hasHref: Bool {return self._href != nil}
  /// Clears the value of `href`. Subsequent reads from it will return its default value.
  mutating func clearHref() {self._href = nil}

  /// accessibility label primarily used by mobile
  var accessibilityLabel: String {
    get {return _accessibilityLabel ?? String()}
    set {_accessibilityLabel = newValue}
  }
  /// Returns true if `accessibilityLabel` has been explicitly set.
  var hasAccessibilityLabel: Bool {return self._accessibilityLabel != nil}
  /// Clears the value of `accessibilityLabel`. Subsequent reads from it will return its default value.
  mutating func clearAccessibilityLabel() {self._accessibilityLabel = nil}

  /// referencing property name primarily used by mobile
  var referencingPropertyName: String {
    get {return _referencingPropertyName ?? String()}
    set {_referencingPropertyName = newValue}
  }
  /// Returns true if `referencingPropertyName` has been explicitly set.
  var hasReferencingPropertyName: Bool {return self._referencingPropertyName != nil}
  /// Clears the value of `referencingPropertyName`. Subsequent reads from it will return its default value.
  mutating func clearReferencingPropertyName() {self._referencingPropertyName = nil}

  /// attribute map primarily used by mobile
  var attributes: Dictionary<String,CoreSdk_V1_Value> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nodeName: String? = nil
  fileprivate var _nodeHtmlClass: String? = nil
  fileprivate var _nodeID: String? = nil
  fileprivate var _nodeText: String? = nil
  fileprivate var _href: String? = nil
  fileprivate var _accessibilityLabel: String? = nil
  fileprivate var _referencingPropertyName: String? = nil
}

/// Extended event details
struct CoreSdk_V1_Interaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// First callback method that fired due to interaction
  var callbackName: String {
    get {return _callbackName ?? String()}
    set {_callbackName = newValue}
  }
  /// Returns true if `callbackName` has been explicitly set.
  var hasCallbackName: Bool {return self._callbackName != nil}
  /// Clears the value of `callbackName`. Subsequent reads from it will return its default value.
  mutating func clearCallbackName() {self._callbackName = nil}

  var kind: CoreSdk_V1_Interaction.OneOf_Kind? = nil

  /// eg. drag-and-dropped. Max 1024 UTF-16 code-units.
  var custom: String {
    get {
      if case .custom(let v)? = kind {return v}
      return String()
    }
    set {kind = .custom(newValue)}
  }

  /// heapjs:t
  var builtin: CoreSdk_V1_Interaction.BuiltinKind {
    get {
      if case .builtin(let v)? = kind {return v}
      return .unspecified
    }
    set {kind = .builtin(newValue)}
  }

  /// string representation of a node hierarchy
  var hierarchy: String {
    get {return _hierarchy ?? String()}
    set {_hierarchy = newValue}
  }
  /// Returns true if `hierarchy` has been explicitly set.
  var hasHierarchy: Bool {return self._hierarchy != nil}
  /// Clears the value of `hierarchy`. Subsequent reads from it will return its default value.
  mutating func clearHierarchy() {self._hierarchy = nil}

  /// hierarchical array of nodes with triggering node first
  var nodes: [CoreSdk_V1_ElementNode] = []

  /// any additional properties
  var sourceProperties: Dictionary<String,CoreSdk_V1_Value> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable {
    /// eg. drag-and-dropped. Max 1024 UTF-16 code-units.
    case custom(String)
    /// heapjs:t
    case builtin(CoreSdk_V1_Interaction.BuiltinKind)

  #if !swift(>=4.1)
    static func ==(lhs: CoreSdk_V1_Interaction.OneOf_Kind, rhs: CoreSdk_V1_Interaction.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.custom, .custom): return {
        guard case .custom(let l) = lhs, case .custom(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.builtin, .builtin): return {
        guard case .builtin(let l) = lhs, case .builtin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Builtin interaction types
  enum BuiltinKind: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// None provided
    case unspecified // = 0

    /// Click
    case click // = 1

    /// Touch
    case touch // = 2

    /// Change
    case change // = 3

    /// Submit
    case submit // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .click
      case 2: self = .touch
      case 3: self = .change
      case 4: self = .submit
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .click: return 1
      case .touch: return 2
      case .change: return 3
      case .submit: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _callbackName: String? = nil
  fileprivate var _hierarchy: String? = nil
}

#if swift(>=4.2)

extension CoreSdk_V1_Interaction.BuiltinKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreSdk_V1_Interaction.BuiltinKind] = [
    .unspecified,
    .click,
    .touch,
    .change,
    .submit,
  ]
}

#endif  // swift(>=4.2)

/// Event property definition
struct CoreSdk_V1_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: CoreSdk_V1_Event.OneOf_Kind? = nil

  /// See Custom message definition
  var custom: CoreSdk_V1_Event.Custom {
    get {
      if case .custom(let v)? = kind {return v}
      return CoreSdk_V1_Event.Custom()
    }
    set {kind = .custom(newValue)}
  }

  /// See interaction message definition
  var interaction: CoreSdk_V1_Interaction {
    get {
      if case .interaction(let v)? = kind {return v}
      return CoreSdk_V1_Interaction()
    }
    set {kind = .interaction(newValue)}
  }

  /// Mobile app_visibility_state
  var appVisibilityState: CoreSdk_V1_Event.AppVisibility {
    get {return _appVisibilityState ?? .unknownUnspecified}
    set {_appVisibilityState = newValue}
  }
  /// Returns true if `appVisibilityState` has been explicitly set.
  var hasAppVisibilityState: Bool {return self._appVisibilityState != nil}
  /// Clears the value of `appVisibilityState`. Subsequent reads from it will return its default value.
  mutating func clearAppVisibilityState() {self._appVisibilityState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable {
    /// See Custom message definition
    case custom(CoreSdk_V1_Event.Custom)
    /// See interaction message definition
    case interaction(CoreSdk_V1_Interaction)

  #if !swift(>=4.1)
    static func ==(lhs: CoreSdk_V1_Event.OneOf_Kind, rhs: CoreSdk_V1_Event.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.custom, .custom): return {
        guard case .custom(let l) = lhs, case .custom(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.interaction, .interaction): return {
        guard case .interaction(let l) = lhs, case .interaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Mobile app visibility
  enum AppVisibility: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Default value for unset/unknown app visibility state.
    case unknownUnspecified // = 0

    /// App is in background
    case backgrounded // = 1

    /// App is in foreground
    case foregrounded // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownUnspecified
      case 1: self = .backgrounded
      case 2: self = .foregrounded
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownUnspecified: return 0
      case .backgrounded: return 1
      case .foregrounded: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A custom event from the `track` API.
  struct Custom {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Custom name of event
    var name: String = String()

    /// Properties from `track`.
    var properties: Dictionary<String,CoreSdk_V1_Value> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _appVisibilityState: CoreSdk_V1_Event.AppVisibility? = nil
}

#if swift(>=4.2)

extension CoreSdk_V1_Event.AppVisibility: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreSdk_V1_Event.AppVisibility] = [
    .unknownUnspecified,
    .backgrounded,
    .foregrounded,
  ]
}

#endif  // swift(>=4.2)

/// Message body
struct CoreSdk_V1_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// string id
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// string env_id
  var envID: String {
    get {return _storage._envID}
    set {_uniqueStorage()._envID = newValue}
  }

  /// string user_id
  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// timestamp of type google.protobuf.Timestamp
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {_uniqueStorage()._time = nil}

  /// The library that implements base functionality.
  var baseLibrary: CoreSdk_V1_LibraryInfo {
    get {return _storage._baseLibrary ?? CoreSdk_V1_LibraryInfo()}
    set {_uniqueStorage()._baseLibrary = newValue}
  }
  /// Returns true if `baseLibrary` has been explicitly set.
  var hasBaseLibrary: Bool {return _storage._baseLibrary != nil}
  /// Clears the value of `baseLibrary`. Subsequent reads from it will return its default value.
  mutating func clearBaseLibrary() {_uniqueStorage()._baseLibrary = nil}

  /// The library providing autocapture or language bridging.
  var sourceLibrary: CoreSdk_V1_LibraryInfo {
    get {return _storage._sourceLibrary ?? CoreSdk_V1_LibraryInfo()}
    set {_uniqueStorage()._sourceLibrary = newValue}
  }
  /// Returns true if `sourceLibrary` has been explicitly set.
  var hasSourceLibrary: Bool {return _storage._sourceLibrary != nil}
  /// Clears the value of `sourceLibrary`. Subsequent reads from it will return its default value.
  mutating func clearSourceLibrary() {_uniqueStorage()._sourceLibrary = nil}

  /// See ApplicationInfo definition
  var application: CoreSdk_V1_ApplicationInfo {
    get {return _storage._application ?? CoreSdk_V1_ApplicationInfo()}
    set {_uniqueStorage()._application = newValue}
  }
  /// Returns true if `application` has been explicitly set.
  var hasApplication: Bool {return _storage._application != nil}
  /// Clears the value of `application`. Subsequent reads from it will return its default value.
  mutating func clearApplication() {_uniqueStorage()._application = nil}

  /// See DeviceInfo definition
  var device: CoreSdk_V1_DeviceInfo {
    get {return _storage._device ?? CoreSdk_V1_DeviceInfo()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {_uniqueStorage()._device = nil}

  /// See SessionInfo message definition
  var sessionInfo: CoreSdk_V1_SessionInfo {
    get {return _storage._sessionInfo ?? CoreSdk_V1_SessionInfo()}
    set {_uniqueStorage()._sessionInfo = newValue}
  }
  /// Returns true if `sessionInfo` has been explicitly set.
  var hasSessionInfo: Bool {return _storage._sessionInfo != nil}
  /// Clears the value of `sessionInfo`. Subsequent reads from it will return its default value.
  mutating func clearSessionInfo() {_uniqueStorage()._sessionInfo = nil}

  /// See pageViewInfo message definition
  var pageviewInfo: CoreSdk_V1_PageviewInfo {
    get {return _storage._pageviewInfo ?? CoreSdk_V1_PageviewInfo()}
    set {_uniqueStorage()._pageviewInfo = newValue}
  }
  /// Returns true if `pageviewInfo` has been explicitly set.
  var hasPageviewInfo: Bool {return _storage._pageviewInfo != nil}
  /// Clears the value of `pageviewInfo`. Subsequent reads from it will return its default value.
  mutating func clearPageviewInfo() {_uniqueStorage()._pageviewInfo = nil}

  /// property map<string, Value>
  var properties: Dictionary<String,CoreSdk_V1_Value> {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  var kind: OneOf_Kind? {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// session
  var session: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .session(let v)? = _storage._kind {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {_uniqueStorage()._kind = .session(newValue)}
  }

  /// pageview
  var pageview: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .pageview(let v)? = _storage._kind {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {_uniqueStorage()._kind = .pageview(newValue)}
  }

  /// see Event message definition
  var event: CoreSdk_V1_Event {
    get {
      if case .event(let v)? = _storage._kind {return v}
      return CoreSdk_V1_Event()
    }
    set {_uniqueStorage()._kind = .event(newValue)}
  }

  /// see User message definition
  var user: CoreSdk_V1_User {
    get {
      if case .user(let v)? = _storage._kind {return v}
      return CoreSdk_V1_User()
    }
    set {_uniqueStorage()._kind = .user(newValue)}
  }

  /// see SessionReplayInfo message definition
  var sessionReplayInfo: CoreSdk_V1_SessionReplayInfo {
    get {return _storage._sessionReplayInfo ?? CoreSdk_V1_SessionReplayInfo()}
    set {_uniqueStorage()._sessionReplayInfo = newValue}
  }
  /// Returns true if `sessionReplayInfo` has been explicitly set.
  var hasSessionReplayInfo: Bool {return _storage._sessionReplayInfo != nil}
  /// Clears the value of `sessionReplayInfo`. Subsequent reads from it will return its default value.
  mutating func clearSessionReplayInfo() {_uniqueStorage()._sessionReplayInfo = nil}

  /// session_replay
  var sessionReplay: String {
    get {return _storage._sessionReplay ?? String()}
    set {_uniqueStorage()._sessionReplay = newValue}
  }
  /// Returns true if `sessionReplay` has been explicitly set.
  var hasSessionReplay: Bool {return _storage._sessionReplay != nil}
  /// Clears the value of `sessionReplay`. Subsequent reads from it will return its default value.
  mutating func clearSessionReplay() {_uniqueStorage()._sessionReplay = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable {
    /// session
    case session(SwiftProtobuf.Google_Protobuf_Empty)
    /// pageview
    case pageview(SwiftProtobuf.Google_Protobuf_Empty)
    /// see Event message definition
    case event(CoreSdk_V1_Event)
    /// see User message definition
    case user(CoreSdk_V1_User)

  #if !swift(>=4.1)
    static func ==(lhs: CoreSdk_V1_Message.OneOf_Kind, rhs: CoreSdk_V1_Message.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.session, .session): return {
        guard case .session(let l) = lhs, case .session(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pageview, .pageview): return {
        guard case .pageview(let l) = lhs, case .pageview(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.event, .event): return {
        guard case .event(let l) = lhs, case .event(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.user, .user): return {
        guard case .user(let l) = lhs, case .user(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// message batch events container
struct CoreSdk_V1_MessageBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// array of events
  var events: [CoreSdk_V1_Message] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension CoreSdk_V1_Utm: @unchecked Sendable {}
extension CoreSdk_V1_SessionReplayInfo: @unchecked Sendable {}
extension CoreSdk_V1_SessionReplayInfo.SessionReplayPlatform: @unchecked Sendable {}
extension CoreSdk_V1_SessionInfo: @unchecked Sendable {}
extension CoreSdk_V1_PageviewInfo: @unchecked Sendable {}
extension CoreSdk_V1_PageviewInfo.Url: @unchecked Sendable {}
extension CoreSdk_V1_User: @unchecked Sendable {}
extension CoreSdk_V1_ElementNode: @unchecked Sendable {}
extension CoreSdk_V1_Interaction: @unchecked Sendable {}
extension CoreSdk_V1_Interaction.OneOf_Kind: @unchecked Sendable {}
extension CoreSdk_V1_Interaction.BuiltinKind: @unchecked Sendable {}
extension CoreSdk_V1_Event: @unchecked Sendable {}
extension CoreSdk_V1_Event.OneOf_Kind: @unchecked Sendable {}
extension CoreSdk_V1_Event.AppVisibility: @unchecked Sendable {}
extension CoreSdk_V1_Event.Custom: @unchecked Sendable {}
extension CoreSdk_V1_Message: @unchecked Sendable {}
extension CoreSdk_V1_Message.OneOf_Kind: @unchecked Sendable {}
extension CoreSdk_V1_MessageBatch: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "core_sdk.v1"

extension CoreSdk_V1_Utm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Utm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "medium"),
    3: .same(proto: "term"),
    4: .same(proto: "content"),
    5: .same(proto: "campaign"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.medium) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.term) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.campaign) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if !self.medium.isEmpty {
      try visitor.visitSingularStringField(value: self.medium, fieldNumber: 2)
    }
    if !self.term.isEmpty {
      try visitor.visitSingularStringField(value: self.term, fieldNumber: 3)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 4)
    }
    if !self.campaign.isEmpty {
      try visitor.visitSingularStringField(value: self.campaign, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_Utm, rhs: CoreSdk_V1_Utm) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.medium != rhs.medium {return false}
    if lhs.term != rhs.term {return false}
    if lhs.content != rhs.content {return false}
    if lhs.campaign != rhs.campaign {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_SessionReplayInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionReplayInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .same(proto: "time"),
    3: .standard(proto: "url_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &self.urlMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.platform != .unspecified {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 1)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.urlMetadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: self.urlMetadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_SessionReplayInfo, rhs: CoreSdk_V1_SessionReplayInfo) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs._time != rhs._time {return false}
    if lhs.urlMetadata != rhs.urlMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_SessionReplayInfo.SessionReplayPlatform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SESSION_REPLAY_PLATFORM_UNSPECIFIED"),
    1: .same(proto: "SESSION_REPLAY_PLATFORM_AURYC"),
    2: .same(proto: "SESSION_REPLAY_PLATFORM_LOGROCKET"),
  ]
}

extension CoreSdk_V1_SessionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "time"),
    3: .same(proto: "referrer"),
    4: .standard(proto: "search_keyword"),
    5: .same(proto: "utm"),
    6: .standard(proto: "initial_pageview_info"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _referrer: String? = nil
    var _searchKeyword: String? = nil
    var _utm: CoreSdk_V1_Utm? = nil
    var _initialPageviewInfo: CoreSdk_V1_PageviewInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _time = source._time
      _referrer = source._referrer
      _searchKeyword = source._searchKeyword
      _utm = source._utm
      _initialPageviewInfo = source._initialPageviewInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._time) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._referrer) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._searchKeyword) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._utm) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._initialPageviewInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._referrer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._searchKeyword {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._utm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._initialPageviewInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_SessionInfo, rhs: CoreSdk_V1_SessionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._referrer != rhs_storage._referrer {return false}
        if _storage._searchKeyword != rhs_storage._searchKeyword {return false}
        if _storage._utm != rhs_storage._utm {return false}
        if _storage._initialPageviewInfo != rhs_storage._initialPageviewInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_PageviewInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PageviewInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "time"),
    3: .standard(proto: "component_or_class_name"),
    4: .same(proto: "title"),
    5: .same(proto: "url"),
    6: .standard(proto: "source_properties"),
    7: .standard(proto: "previous_page"),
    8: .same(proto: "properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._componentOrClassName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &self.sourceProperties) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._previousPage) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &self.properties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._componentOrClassName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.sourceProperties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: self.sourceProperties, fieldNumber: 6)
    }
    try { if let v = self._previousPage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    if !self.properties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: self.properties, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_PageviewInfo, rhs: CoreSdk_V1_PageviewInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._time != rhs._time {return false}
    if lhs._componentOrClassName != rhs._componentOrClassName {return false}
    if lhs._title != rhs._title {return false}
    if lhs._url != rhs._url {return false}
    if lhs.sourceProperties != rhs.sourceProperties {return false}
    if lhs._previousPage != rhs._previousPage {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_PageviewInfo.Url: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreSdk_V1_PageviewInfo.protoMessageName + ".Url"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "path"),
    3: .same(proto: "query"),
    4: .same(proto: "hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_PageviewInfo.Url, rhs: CoreSdk_V1_PageviewInfo.Url) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.path != rhs.path {return false}
    if lhs.query != rhs.query {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "identity"),
    3: .standard(proto: "initial_referrer"),
    4: .standard(proto: "initial_search_keyword"),
    5: .standard(proto: "initial_utm"),
    6: .standard(proto: "initial_pageview_info"),
    7: .same(proto: "properties"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _identity: String = String()
    var _initialReferrer: String? = nil
    var _initialSearchKeyword: String? = nil
    var _initialUtm: CoreSdk_V1_Utm? = nil
    var _initialPageviewInfo: CoreSdk_V1_PageviewInfo? = nil
    var _properties: Dictionary<String,CoreSdk_V1_Value> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _identity = source._identity
      _initialReferrer = source._initialReferrer
      _initialSearchKeyword = source._initialSearchKeyword
      _initialUtm = source._initialUtm
      _initialPageviewInfo = source._initialPageviewInfo
      _properties = source._properties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._initialReferrer) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._initialSearchKeyword) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._initialUtm) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._initialPageviewInfo) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &_storage._properties) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 2)
      }
      try { if let v = _storage._initialReferrer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._initialSearchKeyword {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._initialUtm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._initialPageviewInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._properties.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: _storage._properties, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_User, rhs: CoreSdk_V1_User) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._initialReferrer != rhs_storage._initialReferrer {return false}
        if _storage._initialSearchKeyword != rhs_storage._initialSearchKeyword {return false}
        if _storage._initialUtm != rhs_storage._initialUtm {return false}
        if _storage._initialPageviewInfo != rhs_storage._initialPageviewInfo {return false}
        if _storage._properties != rhs_storage._properties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_ElementNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ElementNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_name"),
    2: .standard(proto: "node_html_class"),
    3: .standard(proto: "node_id"),
    4: .standard(proto: "node_text"),
    5: .same(proto: "href"),
    6: .standard(proto: "accessibility_label"),
    7: .standard(proto: "referencing_property_name"),
    8: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._nodeName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._nodeHtmlClass) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._nodeID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._nodeText) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._href) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._accessibilityLabel) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._referencingPropertyName) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nodeHtmlClass {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._nodeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._nodeText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._href {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._accessibilityLabel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._referencingPropertyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: self.attributes, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_ElementNode, rhs: CoreSdk_V1_ElementNode) -> Bool {
    if lhs._nodeName != rhs._nodeName {return false}
    if lhs._nodeHtmlClass != rhs._nodeHtmlClass {return false}
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._nodeText != rhs._nodeText {return false}
    if lhs._href != rhs._href {return false}
    if lhs._accessibilityLabel != rhs._accessibilityLabel {return false}
    if lhs._referencingPropertyName != rhs._referencingPropertyName {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_Interaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Interaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "callback_name"),
    2: .same(proto: "custom"),
    3: .same(proto: "builtin"),
    4: .same(proto: "hierarchy"),
    5: .same(proto: "nodes"),
    6: .standard(proto: "source_properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._callbackName) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .custom(v)
        }
      }()
      case 3: try {
        var v: CoreSdk_V1_Interaction.BuiltinKind?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .builtin(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._hierarchy) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &self.sourceProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callbackName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    switch self.kind {
    case .custom?: try {
      guard case .custom(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .builtin?: try {
      guard case .builtin(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._hierarchy {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 5)
    }
    if !self.sourceProperties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: self.sourceProperties, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_Interaction, rhs: CoreSdk_V1_Interaction) -> Bool {
    if lhs._callbackName != rhs._callbackName {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs._hierarchy != rhs._hierarchy {return false}
    if lhs.nodes != rhs.nodes {return false}
    if lhs.sourceProperties != rhs.sourceProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_Interaction.BuiltinKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUILTIN_KIND_UNSPECIFIED"),
    1: .same(proto: "BUILTIN_KIND_CLICK"),
    2: .same(proto: "BUILTIN_KIND_TOUCH"),
    3: .same(proto: "BUILTIN_KIND_CHANGE"),
    4: .same(proto: "BUILTIN_KIND_SUBMIT"),
  ]
}

extension CoreSdk_V1_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "custom"),
    2: .same(proto: "interaction"),
    20: .standard(proto: "app_visibility_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CoreSdk_V1_Event.Custom?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .custom(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .custom(v)
        }
      }()
      case 2: try {
        var v: CoreSdk_V1_Interaction?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .interaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .interaction(v)
        }
      }()
      case 20: try { try decoder.decodeSingularEnumField(value: &self._appVisibilityState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .custom?: try {
      guard case .custom(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .interaction?: try {
      guard case .interaction(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._appVisibilityState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 20)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_Event, rhs: CoreSdk_V1_Event) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._appVisibilityState != rhs._appVisibilityState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_Event.AppVisibility: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_VISIBILITY_UNKNOWN_UNSPECIFIED"),
    1: .same(proto: "APP_VISIBILITY_BACKGROUNDED"),
    2: .same(proto: "APP_VISIBILITY_FOREGROUNDED"),
  ]
}

extension CoreSdk_V1_Event.Custom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreSdk_V1_Event.protoMessageName + ".Custom"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &self.properties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.properties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: self.properties, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_Event.Custom, rhs: CoreSdk_V1_Event.Custom) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "env_id"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "time"),
    5: .standard(proto: "base_library"),
    6: .standard(proto: "source_library"),
    7: .same(proto: "application"),
    8: .same(proto: "device"),
    9: .standard(proto: "session_info"),
    10: .standard(proto: "pageview_info"),
    11: .same(proto: "properties"),
    12: .same(proto: "session"),
    13: .same(proto: "pageview"),
    14: .same(proto: "event"),
    15: .same(proto: "user"),
    16: .standard(proto: "session_replay_info"),
    17: .standard(proto: "session_replay"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _envID: String = String()
    var _userID: String = String()
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _baseLibrary: CoreSdk_V1_LibraryInfo? = nil
    var _sourceLibrary: CoreSdk_V1_LibraryInfo? = nil
    var _application: CoreSdk_V1_ApplicationInfo? = nil
    var _device: CoreSdk_V1_DeviceInfo? = nil
    var _sessionInfo: CoreSdk_V1_SessionInfo? = nil
    var _pageviewInfo: CoreSdk_V1_PageviewInfo? = nil
    var _properties: Dictionary<String,CoreSdk_V1_Value> = [:]
    var _kind: CoreSdk_V1_Message.OneOf_Kind?
    var _sessionReplayInfo: CoreSdk_V1_SessionReplayInfo? = nil
    var _sessionReplay: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _envID = source._envID
      _userID = source._userID
      _time = source._time
      _baseLibrary = source._baseLibrary
      _sourceLibrary = source._sourceLibrary
      _application = source._application
      _device = source._device
      _sessionInfo = source._sessionInfo
      _pageviewInfo = source._pageviewInfo
      _properties = source._properties
      _kind = source._kind
      _sessionReplayInfo = source._sessionReplayInfo
      _sessionReplay = source._sessionReplay
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._envID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._time) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._baseLibrary) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sourceLibrary) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._application) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._sessionInfo) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._pageviewInfo) }()
        case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: &_storage._properties) }()
        case 12: try {
          var v: SwiftProtobuf.Google_Protobuf_Empty?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .session(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .session(v)
          }
        }()
        case 13: try {
          var v: SwiftProtobuf.Google_Protobuf_Empty?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .pageview(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .pageview(v)
          }
        }()
        case 14: try {
          var v: CoreSdk_V1_Event?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .event(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .event(v)
          }
        }()
        case 15: try {
          var v: CoreSdk_V1_User?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .user(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .user(v)
          }
        }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._sessionReplayInfo) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._sessionReplay) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._envID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._envID, fieldNumber: 2)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 3)
      }
      try { if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._baseLibrary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sourceLibrary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._application {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._sessionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._pageviewInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._properties.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreSdk_V1_Value>.self, value: _storage._properties, fieldNumber: 11)
      }
      switch _storage._kind {
      case .session?: try {
        guard case .session(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .pageview?: try {
        guard case .pageview(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .event?: try {
        guard case .event(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .user?: try {
        guard case .user(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case nil: break
      }
      try { if let v = _storage._sessionReplayInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._sessionReplay {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_Message, rhs: CoreSdk_V1_Message) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._envID != rhs_storage._envID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._baseLibrary != rhs_storage._baseLibrary {return false}
        if _storage._sourceLibrary != rhs_storage._sourceLibrary {return false}
        if _storage._application != rhs_storage._application {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._sessionInfo != rhs_storage._sessionInfo {return false}
        if _storage._pageviewInfo != rhs_storage._pageviewInfo {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._sessionReplayInfo != rhs_storage._sessionReplayInfo {return false}
        if _storage._sessionReplay != rhs_storage._sessionReplay {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreSdk_V1_MessageBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreSdk_V1_MessageBatch, rhs: CoreSdk_V1_MessageBatch) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
